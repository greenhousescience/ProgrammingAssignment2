s <- split(airquality, airquality$Month)
lapply(s, function(x) colMeans(x[, c("Ozone", "Solar.R", "Wind")]))
lapply(s, function(x) colMeans(x[, c("Ozone", "Solar.R", "Wind", "Temp")]))
sapply(x, function(x) colMeans(x[, c("Ozone", "Solar.R", "Wind")], na.rm=TRUE))
x<- rnorm(10)
f1 <- gl(2,5)
f2 <_ g2(5,2)
f1
f2 <- g2(5,2)
f2 <_ g1(5,2)
f2 <- gl(5,2)
f1
f2
interaction(f1,f2)
str(split(x, list(f1,f2)))
str(split(x, list(f1,f2), drop=TRUE))
printmessage <- function(x) {
if(x>0> print ('x is greater than zero'))
}
printmessage <- function(x) {
if(x>0> print ('x is greater than zero'))
else print ('x is less than or equal to zero')
invisible(x)
}
printmessage2 <- function(x) {
if (is.na(x))
print ("x is a missing value!")
else if(x>0)
print ("x is greater than zero")
else
print("x is less than or equal to zero")
invisible(x)
}
x <- log(-1)
printmessage2(x)
bivVec <- makeVector(1:1000)
makeVector <- function(x=numeric()) {
m <- NULL
get <- function()
setmeans <- function(mean)
getmeans <- function()
list(get=get, setmean=setmean, getmean=getmean)
cachemean <- function(x, ...)
m <- x$getmean()
if(!is.null(m)) {
message("Getting cached data")
return(m)
}
data <- x$get()
m <- mean(data, ...)
x$setmean(m)
m
}
bigBec <- makeVector(1:1000)
BigVec <- (1:1000)
BigVec$getmean()
## Put comments here that give an overall description of what your
## functions do
## This function takes a matrix, initializes a temporary cache and
## calculates the inverse of the matrix, which it stores in the cache.
makeMatrix <- function(x = matrix()) {
v <- NULL
get <- function() {x}
setInverse <- function() {v <<- solve(x)}
getInverse <- function() {v}
list (get=get, setInverse=setInverse, getInverse=getInverse)
## This function returns a matrix that is the inverse of 'x', but first
## verifies if the value has already been calculated and stored in the
## cache.
cacheSolve <- function(x, ...) {
If (!is.null(v)) { message("Getting cached data")
return(v)
}
data <- x$get {x}
v <<- setInverse(x)
}
## Put comments here that give an overall description of what your
## functions do
## This function takes a matrix, initializes a temporary cache and
## calculates the inverse of the matrix, which it stores in the cache.
makeMatrix <- function(x = matrix()) {
v <- NULL
get <- function() {x}
setInverse <- function() {v <<- solve(x)}
getInverse <- function() {v}
list (get=get, setInverse=setInverse, getInverse=getInverse)
## This function returns a matrix that is the inverse of 'x', but first
## verifies if the value has already been calculated and stored in the
## cache.
cacheSolve <- function(x, ...) {
If (!is.null(v))
message("Getting cached data")
return(v)
}
data <- x$get {x}
v <<- setInverse(x)
}
## Put comments here that give an overall description of what your
## functions do
## This function takes a matrix, initializes a temporary cache and
## calculates the inverse of the matrix, which it stores in the cache.
makeMatrix <- function(x = matrix()) {
v <- NULL
get <- function() {x}
setInverse <- function() {v <<- solve(x)}
getInverse <- function() {v}
list (get=get, setInverse=setInverse, getInverse=getInverse)
## This function returns a matrix that is the inverse of 'x', but first
## verifies if the value has already been calculated and stored in the
## cache.
cacheSolve <- function(x, ...) {
If (!is.null(v))
message("Getting cached data")
return(v)
}
data <- x$get ##{x}
v <<- setInverse(x)
}
makeMatrix(x=matrix(1:4,2,2))
## Put comments here that give an overall description of what your
## functions do
## This function, "makeVector", creates a special "vectpr", which
## is really a list containing a function to
## 1. set the value of the vector
##2. get the value of the vector
## 3. set the value of the inverse
##4. get the value of the inverse
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m<<- NULL
}
get <- function() x
setInverse <- function() v <<- solve(x)
getInverse <- function() v
list (set=set, get=get, setInverse=setInverse, getInverse=getInverse)
}
## This second function calculates the inverse of the special "vector"
## created with the above function. However, it first verifies if the
## inverse has already been calculated. If so, it "gets" the inverse
## from the cache and skips the computation. Otherwise, it calculates
## the inverse of the vector and sets its value in the cache via the
## "setInverse" function
cacheSolve <- function(x, ...) {
v <- x$getInverse()
If (!is.null(v)) {
message("Getting cached data")
return(v)
}
data <- x$get()
v <<- x$setInverse()
v
}
## Put comments here that give an overall description of what your
## functions do
## This function, "makeVector", creates a special "vectpr", which
## is really a list containing a function to
## 1. set the value of the vector
##2. get the value of the vector
## 3. set the value of the inverse
##4. get the value of the inverse
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m<<- NULL
}
get <- function() x
setInverse <- function() v <<- solve(x)
getInverse <- function() v
list (set=set, get=get, setInverse=setInverse, getInverse=getInverse)
}
## This second function calculates the inverse of the special "vector"
## created with the above function. However, it first verifies if the
## inverse has already been calculated. If so, it "gets" the inverse
## from the cache and skips the computation. Otherwise, it calculates
## the inverse of the vector and sets its value in the cache via the
## "setInverse" function
cacheSolve <- function(x, ...) {
v <- x$getInverse()
If (!is.null(v))
message("Getting cached data")
return(v)
data <- x$get()
v <<- x$setInverse()
v
}
x <- numeric(1:4,2,2)
x<- matrix(1:4,2,2)
cacheSolve(x)
solve(x)
?numeric
x(1:4)
x<-c(1:4)
x<-numeric(1:4)
cacheSolve(x)
## This function, "makeVector", creates a special "vectpr", which
## is really a list containing a function to
## 1. set the value of the vector
##2. get the value of the vector
## 3. set the value of the inverse
##4. get the value of the inverse
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m<<- NULL
}
get <- function() x
setInverse <- function() v <<- solve(x)
getInverse <- function() v
list (set=set, get=get, setInverse=setInverse, getInverse=getInverse)
}
## This second function calculates the inverse of the special "vector"
## created with the above function. However, it first verifies if the
## inverse has already been calculated. If so, it "gets" the inverse
## from the cache and skips the computation. Otherwise, it calculates
## the inverse of the vector and sets its value in the cache via the
## "setInverse" function
cacheSolve <- function(x, ...) {
v <- x$getInverse()
If (!is.null(v))
message("Getting cached data")
return(v)
data <- x$get()
v <<- x$setInverse()
v
}
bv <- makeVector(1:10)
cacheSolve(bv)
## This function, "makeVector", creates a special "vectpr", which
## is really a list containing a function to
## 1. set the value of the vector
##2. get the value of the vector
## 3. set the value of the inverse
##4. get the value of the inverse
makeVector <- function(x = numeric()) {
v <- NULL
set <- function(y) {
x <<- y
v <<- NULL
}
get <- function() x
setInverse <- function() v <<- solve(x)
getInverse <- function() v
list (set=set, get=get, setInverse=setInverse, getInverse=getInverse)
}
## This second function calculates the inverse of the special "vector"
## created with the above function. However, it first verifies if the
## inverse has already been calculated. If so, it "gets" the inverse
## from the cache and skips the computation. Otherwise, it calculates
## the inverse of the vector and sets its value in the cache via the
## "setInverse" function
cacheSolve <- function(x, ...) {
v <- x$getInverse()
If (!is.null(v))
message("Getting cached data")
return(v)
data <- x$get()
v <<- x$setInverse()
v
}
cacheSolve(bv)
v<- NULL
cacheSolve(bv)
x c(1:4,2,2)
x <- c(1:4,2,2)
x<-matrix(1:4,2,2)
m<- NULL
x <<- y
## This function, "makeVector", creates a special "vectpr", which
## is really a list containing a function to
## 1. set the value of the vector
##2. get the value of the vector
## 3. set the value of the inverse
##4. get the value of the inverse
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setInverse <- function() m <<- solve(x)
getInverse <- function() m
list (set=set, get=get, setInverse=setInverse, getInverse=getInverse)
}
## This second function calculates the inverse of the special "vector"
## created with the above function. However, it first verifies if the
## inverse has already been calculated. If so, it "gets" the inverse
## from the cache and skips the computation. Otherwise, it calculates
## the inverse of the vector and sets its value in the cache via the
## "setInverse" function
cacheSolve <- function(x, ...) {
m <- x$getInverse()
If (!is.null(m))
message("Getting cached data")
return(m)
}
data <- x$get()
m <- x$setInverse()
m
}
## This function, "makeVector", creates a special "vectpr", which
## is really a list containing a function to
## 1. set the value of the vector
##2. get the value of the vector
## 3. set the value of the inverse
##4. get the value of the inverse
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setInverse <- function() m <<- solve(x)
getInverse <- function() m
list (set=set, get=get, setInverse=setInverse, getInverse=getInverse)
}
## This second function calculates the inverse of the special "vector"
## created with the above function. However, it first verifies if the
## inverse has already been calculated. If so, it "gets" the inverse
## from the cache and skips the computation. Otherwise, it calculates
## the inverse of the vector and sets its value in the cache via the
## "setInverse" function
cacheSolve <- function(x, ...) {
m <- x$getInverse()
If (!is.null(m))
message("Getting cached data")
return(m)
}
data <- x$get()
m <- x$setInverse()
m
}
list(set=set, get=get, setInverse=setInvers, getInverse=getInverse)
x<- numeric()
m <- NULL
set <- function(y){x<<- y m<<- NULL}
set <- function(y){
x<<- y
m<<- NULL
}
## This function, "makeVector", creates a special "vectpr", which
## is really a list containing a function to
## 1. set the value of the vector
##2. get the value of the vector
## 3. set the value of the inverse
##4. get the value of the inverse
makeVector <- function(x = numeric()) {
m <- NULL
set <- function() m <<- NULL
get <- function() x
setInverse <- function() m <<- solve(x)
getInverse <- function() m
list (set=set, get=get, setInverse=setInverse, getInverse=getInverse)
}
## This second function calculates the inverse of the special "vector"
## created with the above function. However, it first verifies if the
## inverse has already been calculated. If so, it "gets" the inverse
## from the cache and skips the computation. Otherwise, it calculates
## the inverse of the vector and sets its value in the cache via the
## "setInverse" function
cacheSolve <- function(x, ...) {
m <- x$getInverse()
If (!is.null(m))
message("Getting cached data")
return(m)
}
data <- x$get()
m <- x$setInverse()
m
}
x <- list(set=set, get=get, setInverse=setInverse, getInverse=getInverse)
## This function, "makeVector", creates a special "vectpr", which
## is really a list containing a function to
## 1. set the value of the vector
##2. get the value of the vector
## 3. set the value of the inverse
##4. get the value of the inverse
makeVector <- function(x = numeric()) {
m <- NULL
get <- function() x
setInverse <- function() m <<- solve(x)
getInverse <- function() m
list(get=get, setInverse=setInverse, getInverse=getInverse)
}
## This second function calculates the inverse of the special "vector"
## created with the above function. However, it first verifies if the
## inverse has already been calculated. If so, it "gets" the inverse
## from the cache and skips the computation. Otherwise, it calculates
## the inverse of the vector and sets its value in the cache via the
## "setInverse" function
cacheSolve <- function(x, ...) {
m <- x$getInverse()
If (!is.null(m))
message("Getting cached data")
return(m)
}
data <- x$get()
m <- solve(x)
x$setInverse(m)
m
}
makeVector(x=(1:4))
cacheSolve(x)
cacheSolve(x=1:4))
cacheSolve(x=1:4)
mat <- matrix(1:4, 2,2)
source("cachmatrix.R")
source("cachmetrix.R")
source("cachematrix.R")
getwd()
setwd("C/Users/Ève")
setwd("C:/Users/Ève")
ls
setwd("C:/Users/Ève/ProgrammingAssignment2")
source("cachematrix.R")
solve(mat)
matObj <- makeCacheMatrix(mat)
matObj <- makeVector(mat)
list()
lis(set=set, get=get, setInverse=setInverse, getInverse=getInverse)
list(set=set, get=get, setInverse=setInverse, getInverse=getInverse)
source("cachmatrix.R")
source("cachematrix.R")
source("cachematrix.R")
mymatrix <- matrix(1:4,2,2)
makeVector(mymatrix)
cachesolve(mymatrix)
cachSolve(mymatrix)
cacheSolve(mymatrix)
Inv
makeVector(mymatrix)
source("cachematrix.R")
mymatrix <- matrix(1:12, 3,4)
mymatrix
solve(mymatrix)
mymatrix <- matrix(1:9, 3,3)
solve(mymatrix)
mymatrix(1:4,2,2)
mymatrix <- matrix(1:4,2,2)
solve(mymatrix)
makeVector(mymatrix)
source("cachematrix.R")
mat <- matrix(1:4,2,2)
makeVector(mat)
source("cachematrix.R")
makeVector(mat)
inv <- NULL
list()
^list
?list
source("cachematrix.R")
makeVector(mat)
source("cachematrix.R")
makeVector(mat)
cacheSolve(mat)
mat
source("cachematrix.R")
makeVector(mat)
cacheSolve(mat)
source("cachematrix.R")
source("cachematrix.R")
makeVector(x=mat)
mat
list
inv
setInverse
source("cachematrix.R")
makeVector(mat<-(1:4,2,2))
makeVector(mat<-matrix(1:4,2,2))
inv
mat
source("cachematrix.R")
mat <- matrix(1:4,2,2)
makeVector(mat)
solve(mat)
get <- function() x
get
set <- function(y)
x <<-y
Inv <<- NULL
setInvers <- function() Inv <<- solve(x)
setInvers
getInverse<- function() Inv
getInverse
setInverse <- setInvers
list(set=set, get=get, setInverse=setInverse, getInverse=getInvers)
list(set=set, get=get, setInverse=setInverse, getInverse=getInverse)
list
CacheSolve(mat)
source("cachematrix.R")
mat <- matrix(1:4,2,2)
MakeVector(mat)
cacheSolve(mat)
source("cachematrix.R")
source("cachematrix.R")
mat <- matrix(1:4,2,2)
solve(mat)
makeVector(mat)
cachSolve(mat)
cacheSolve(mat)
mat$getInverse()
source("cachematrix.R")
mat <- matrix(1:4,2,2)
makeVector(mat)
cacheSolve(mat)
<- Inv <- mat@getInverse()
Inv <- mat@getInverse()
